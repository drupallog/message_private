<?php
/**
 * @file
 * Message Private with access permissions based on message fields.
 */

use Drupal\Core\Routing\RouteMatchInterface;

/**
 * The string name for message limit variable.
 */
const MESSAGE_PRIVATE_MESSAGE_LIMIT = 'message_private_message_limit';

/**
 * The assoc index to be used when fetching default limit variable.
 */
const MESSAGE_PRIVATE_DEFAULT_LIMIT = 'message_private_default_limit';

/**
 * The assoc index to be used when fetching default interval variable.
 */
const MESSAGE_PRIVATE_DEFAULT_INTERVAL = 'message_private_default_interval';

/**
 * The default index for settings such as role.
 */
const MESSAGE_PRIVATE_DEFAULT_INDEX = 0;

/**
 * The maximum message limit.
 */
const MESSAGE_PRIVATE_MESSAGE_LIMIT_MAX = 1000;

/**
 * The minimum message limit.
 */
const MESSAGE_PRIVATE_MESSAGE_LIMIT_MIN = 1;

/**
 * The maximum message interval in minutes.
 */
const MESSAGE_PRIVATE_MESSAGE_INTERVAL_MAX = 1440;

/**
 * The minimum message interval in minutes.
 */
const MESSAGE_PRIVATE_MESSAGE_INTERVAL_MIN = 1;


/**
 * Implements hook_help().
 */
function message_private_help($route_name, RouteMatchInterface $arg) {
  switch ($route_name) {
    case 'help.page.message_private':
      $output = file_get_contents(drupal_get_path('module', 'message_private') . '/README.md');
      return \Drupal::moduleHandler()->moduleExists('markdown') ? \Drupal\Component\Utility\Xss::filterAdmin(\Drupal::moduleHandler()->invoke('markdown', 'filter', ['process', 0, -1, $output])) : '<h3>Message Private README</h3><pre>' . \Drupal\Component\Utility\Html::escape($output) . '</pre>';
  }
}

/**
 * Implements hook_entity_type_alter.
 *
 * Extend the message entity type by providing form handlers.
 * @todo : can access handler be added to certain bundle only?
 */
function message_ui_entity_type_alter(array &$entity_types) {
  if (isset($entity_types['message'])) {
    /* @var $message_config \Drupal\Core\Config\Entity\ConfigEntityType */
    $message_config = $entity_types['message'];
    $message_config->setAccessClass('Drupal\message_private\MessagePrivateAccessControlHandler');
  }
}

/**
 * Access callback for Messages tab.
 *
 * Checks for the private_message bundle and user permissions.
 *
 * @param object $message
 *   The message object.
 *
 * @return bool
 *   TRUE if the user is allowed perform the operation, FALSE otherwise.
 */
// @todo: convert to Access class and add associated service and entry in route.
function message_private_access_callback($message) {
  if ($message->type == 'private_message') {
    return \Drupal::currentUser()->hasPermission('bypass private message access control') || \Drupal::currentUser()->hasPermission('view a private_message message instance');
  }
  return FALSE;
}

/**
 * Implements hook_menu_alter().
 *
 * Override some of the menu paths set in message ui module.
 */
function message_private_menu_alter(&$items) {

  // Override access callbacks.
  // @todo: add appropriate callbacks to services refering to node.services.yml.
  $items['message/%message']['access callback'] = 'message_private_access_control';
  $items['message/%message/view']['access callback'] = 'message_private_access_control';
  $items['message/%message/edit']['access callback'] = 'message_private_access_control';
  $items['message/%message/delete']['access callback'] = 'message_private_access_control';

  // Override page created by message_ui to allow custom "Private Message" URI.
  $items['admin/content/message/create']['page callback'] = 'message_private_create_new_message_instance_list';

  // Unset menu item created by message_ui for private_message type.
  unset($items['admin/content/message/create/private-message']);

  return $items;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * This function is defined to override that provided by Message UI module. This
 * allows override specific values of the form such as the cancel link. It hides
 * the message_text on the edit and create form, and adds custom validation.
 */
// @todo - check form ID is matching D8 form id.

function message_private_form_message_private_message_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  $entity = $form_state->getFormObject()->getEntity();
  if ($entity->bundle() == 'private_message') {
    $user = \Drupal::currentUser();

    /* // There is no cancel link on node form, so this may be unnecessary now.
     $referer = $_SERVER['HTTP_REFERER']; // Get the referrer uri from globals.
    // Redirect back to referer uri is exists, otherwise to user message inbox.
    // @FIXME
// l() expects a Url object, created from a route name or external URI.
// $form['actions']['cancel']['#markup'] =
      l(t('Cancel'), (!empty($referer) ? $referer : 'user/'. $user->uid . '/messages'));*/

    if (isset($form['text']['#type'])) {
      $form['text']['#type'] = 'hidden'; // @todo - is this necessary now?
    }

    // @todo - owner access and validation callback needs testing.
    $form['owner']['#access'] = \Drupal::currentUser()->hasPermission('bypass private message access control');
    $form['#validate'][] = 'message_private_form_message_private_message_form_validate';
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
// @todo - remove in place of a dynamic local task class.
function message_private_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  $user = \Drupal::currentUser();

  switch ($root_path) {
    case 'user/%':
      // Add a 'Create a new message for %user' action link.
      if (is_array($router_item['page_arguments'])) {
        // Get the user object from page arguments.
        foreach ($router_item['page_arguments'] as $arg) {
          if (is_object($arg) && !empty($arg->uid)) {
            $to_user = $arg;
          }
        }
      }
      // Only display the local task on other users profile, not current user's.
      if (!empty($to_user) && $user->uid != $to_user->uid) {
        // @FIXME
// menu_get_item() has been removed. To retrieve route information, use the
// RouteMatch object, which you can retrieve by calling \Drupal::routeMatch().
// 
// 
// @see https://www.drupal.org/node/2203305
// $item = menu_get_item('message/create/private-message');

        $item['title'] = t('Create a new message for') . ' ' . $to_user->name;
        $item['localized_options']['query'] = array('field_message_user_ref' => $to_user->uid);
        $data['actions']['output'][] = array(
          '#theme' => 'menu_local_action',
          '#link' => $item,
        );

      }
      break;

    case 'user/%/messages':
      // Add a 'Create a new message' action link above message_private view.
      // @FIXME
// menu_get_item() has been removed. To retrieve route information, use the
// RouteMatch object, which you can retrieve by calling \Drupal::routeMatch().
// 
// 
// @see https://www.drupal.org/node/2203305
// $item = menu_get_item('message/create/private-message');

      $item['title'] = t('Create a new message');
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
      );

      break;

    case 'message/%':
      $message = \Drupal::routeMatch()->getParameter('message', 1, $router_item['href']);
      if (isset($message->type) && $message->type == 'private_message') {
        // Add a Messages tab to the private_message Message entities.
        // @FIXME
// menu_get_item() has been removed. To retrieve route information, use the
// RouteMatch object, which you can retrieve by calling \Drupal::routeMatch().
// 
// 
// @see https://www.drupal.org/node/2203305
// $item = menu_get_item('user/' . $user->uid . '/messages');

        $item['title'] = t('Messages');
        $data['tabs'][0]['output'][] = array(
          '#theme' => 'menu_local_task',
          '#link' => $item,
        );

        // Get from user to Add a 'Create a new message for %user' action link.
        $to_user = \Drupal::entityManager()->getStorage('user')->load($message->uid);
        // Display the local task on other users profile, not current user's.
        if (!empty($to_user) && $user->uid != $to_user->uid) {
          // @FIXME
// menu_get_item() has been removed. To retrieve route information, use the
// RouteMatch object, which you can retrieve by calling \Drupal::routeMatch().
// 
// 
// @see https://www.drupal.org/node/2203305
// $item = menu_get_item('message/create/private-message');

          $item['title'] = t('Create a new message for') . ' ' . $to_user->name;
          $item['localized_options']['query'] = array('field_message_user_ref' => $to_user->uid);
          $data['actions']['output'][] = array(
            '#theme' => 'menu_local_action',
            '#link' => $item,
          );

        }
      }
      break;

  }
}

/**
 * Validation for Private Message form.
 *
 * @param mixed $form
 *   The message form provided by message_ui.
 * @param mixed $form_state
 *   The form state including values submitted.
 */
// @todo - test this is called and if form should be passed by reference.
function message_private_form_message_private_message_form_validate($form, \Drupal\Core\Form\FormStateInterface $form_state) {
  // If there is an imposed message limit set in the admin settings interface.
  // @FIXME
// // @FIXME
// // The correct configuration object could not be determined. You'll need to
// // rewrite this call manually.
// if (variable_get(MESSAGE_PRIVATE_MESSAGE_LIMIT, FALSE)
//     && !\Drupal::currentUser()->hasPermission('bypass private message access control')) {
//     $user = \Drupal::currentUser();
// 
//     // Get the role belonging to user with max message limit.
//     $rid = _message_private_max_message_limit_role($user->roles);
//     $role = user_role_load($rid);
// 
//     // Get the message limitation settings for this role.
//     $role_name = str_replace(' ', '_', $role->name);
//     $limit_name = 'message_private_' . $role_name . '_limit';
//     $interval_name = 'message_private_' . $role_name . '_interval';
//     $interval = variable_get($interval_name);
//     $limit = variable_get($limit_name);
// 
//     // Calculate timestamp of the last interval.
//     $current_timestamp = time();
//     $interval_timestamp = strtotime('-' . $interval . ' minutes', $current_timestamp);
// 
//     // Get total amount of this user's messages since last interval.
//     $query = new EntityFieldQuery();
//     $total = $query->entityCondition('entity_type', 'message')
//       ->entityCondition('bundle', 'private_message')
//       ->propertyCondition('timestamp', $interval_timestamp, '>')
//       ->propertyCondition('uid', $user->uid)
//       ->count()
//       ->execute();
// 
//     // Display error preventing message create when total messages over limit.
//     if ($total >= $limit) {
//       form_error($form, t('Message create limit reached. Please try again later.'));
//     }
//   }

}

/**
 * Implements hook_message_insert().
 *
 * Send an email if a private message has been created.
 *
 * Currently addslashes() or equivalent is not used on the email,
 * this may be an issue with the message module itself as I don't
 * think escaping strings for email should be done in this module.
 */
function message_private_message_insert(\Drupal\message\MessageInterface $message) {
  // Prepare message notifications for private messages if notifications are on.
  // @FIXME
// // @FIXME
// // The correct configuration object could not be determined. You'll need to
// // rewrite this call manually.
// if ($message->type == 'private_message'
//     && variable_get(MESSAGE_PRIVATE_EMAIL_NOTIFICATIONS, TRUE)) {
//     // Use message load as the $message object has issue with mail function.
//     // It causes duplicate entry, possibly as mid is missing and the mail
//     // function message_notify_send_message tries to re-save as a new message.
//     $message = message_load($message->mid);
//     $wrapper = entity_metadata_wrapper('message', $message);
// 
//     $mail = array();
//     $users = $wrapper->field_message_user_ref->value();
// 
//     if (is_array($users)) {
//       foreach ($users as $user) {
//         $notify = field_get_items('user', $user, 'field_private_message_notify');
//         if (!empty($notify) && is_array($notify)) {
//           // Get the 1st value of the array as there is only 1 possible item.
//           $notify = array_shift($notify);
//         }
//         // If the user has set field for notifications, add their email.
//         if (isset($notify['value']) && $notify['value']) {
//           $mail[] = $user->mail;
//         }
//       }
//     }
//     if (!empty($mail)) {
//       message_notify_send_message($message, array('mail' => implode(',', $mail)));
//     }
//   }

}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * If email notifications are disabled, hide the per user setting on user
 * profiles, unless the user is in role with bypass access control permission.
 */
// @todo - check form ID is matching D8 form id.
function message_private_form_user_profile_form_alter(&$form, &$form_state, $form_id) {
  // @FIXME
// // @FIXME
// // The correct configuration object could not be determined. You'll need to
// // rewrite this call manually.
// if (!\Drupal::currentUser()->hasPermission('bypass private message access control')
//     && !variable_get(MESSAGE_PRIVATE_EMAIL_NOTIFICATIONS, TRUE)) {
//     $form['field_private_message_notify']['#access'] = FALSE;
//   }

}

/**
 * Implements hook_theme().
 */
// @todo - Is this still required in D8 to make twig template discoverable?
function message_private_theme() {
  $info['message_private'] = array(
    'render element' => 'elements',
    'template' => 'message--private_message',
    'base hook' => 'message_private',
  );

  return $info;
}

/**
 * Implements hook_message_view_alter().
 */
// @todo - Is this still required in D8 to make twig template discoverable?
function message_private_message_view_alter(&$build) {
  // Use template_preprocess_message_private for private_message messages only.
  if (!empty($build['#bundle']) && $build['#bundle'] == 'private_message') {
    $build['#theme'] = 'message_private';
  }
}

/**
 * Process variables for message--private_message.html.twig.
 */
// @todo - Is there a better alternative to this?
function template_preprocess_message_private(&$variables) {
  // Call the parent message template function defined in message module.
  if (function_exists('template_preprocess_message')) {
    template_preprocess_message($variables);
  }
  // Save the message entity for ease of access.
  if (is_object($variables['elements']['#entity'])) {
    $message = $variables['elements']['#entity'];
  }
  // Create submitted variable containing user who created the message and date.
  if (!empty($message) && $uid = $message->uid) {
    $variables['date'] = format_date($message->timestamp);
    // @FIXME
// theme() has been renamed to _theme() and should NEVER be called directly.
// Calling _theme() directly can alter the expected output and potentially
// introduce security issues (see https://www.drupal.org/node/2195739). You
// should use renderable arrays instead.
// 
// 
// @see https://www.drupal.org/node/2195739
// $variables['name'] = theme('username', array('account' => user_load($uid)));

    $variables['submitted'] = t('Submitted by !username on !datetime', array(
        '!username' => $variables['name'],
        '!datetime' => $variables['date'],
    ));
  }
}

/**
 * Get the role id with the maximum allowed message create limit.
 *
 * Using the values set for each role, calculate the the lowest time interval
 * required per message: INTERVAL / LIMIT and return the role with this value.
 *
 * @param null|array $roles
 *   An assoc array of role names and ids.
 *
 * @return mixed
 *   Either a role id or null.
 */
// @todo - Is there a better location for this?
function _message_private_max_message_limit_role($roles) {
  $limits = array();
  // @FIXME
// // @FIXME
// // The correct configuration object could not be determined. You'll need to
// // rewrite this call manually.
// $limit = variable_get(MESSAGE_PRIVATE_DEFAULT_LIMIT);

  // @FIXME
// // @FIXME
// // The correct configuration object could not be determined. You'll need to
// // rewrite this call manually.
// $interval = variable_get(MESSAGE_PRIVATE_DEFAULT_INTERVAL);

  // Ensure we have existing valid numerical values for both variables.
  if (!empty($limit) && ctype_digit($limit) && !empty($interval) && ctype_digit($interval)) {
    $limits[MESSAGE_PRIVATE_DEFAULT_INDEX] = $interval / $limit;
  }

  // Cycle through the roles and get each limit and interval.
  foreach ($roles as $rid => $role) {
    $role_name = str_replace(' ', '_', $role);
    $limit_name = 'message_private_' . $role_name . '_limit';
    $interval_name = 'message_private_' . $role_name . '_interval';
    // @FIXME
// // @FIXME
// // The correct configuration object could not be determined. You'll need to
// // rewrite this call manually.
// $interval = variable_get($interval_name);

    // @FIXME
// // @FIXME
// // The correct configuration object could not be determined. You'll need to
// // rewrite this call manually.
// $limit = variable_get($limit_name);


    // Ensure we have existing valid numerical values for both variables.
    if (!empty($limit) && ctype_digit($limit) && !empty($interval) && ctype_digit($interval)) {
      $limits[$rid] = $interval / $limit;
    }
  }
  // The min value corresponds to the lowest interval required per message.
  return array_search(min($limits), $limits);
}
